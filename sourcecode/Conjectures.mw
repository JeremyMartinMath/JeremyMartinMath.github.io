<?xml version="1.0" encoding="UTF-8"?>
<Worksheet><Version major="6" minor="1"/><View-Properties><Zoom percentage="100"/></View-Properties><Styles><Layout alignment="left" bullet="none" name="Warning"/><Layout alignment="left" bullet="none" name="Error"/><Layout alignment="left" bullet="none" firstindent="0.0" leftmargin="0.0" linebreak="space" linespacing="0.0" name="Normal" rightmargin="0.0" spaceabove="0.0" spacebelow="0.0"/><Layout alignment="centred" bullet="none" linespacing="0.5" name="Maple Output"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="Maple Input" opaque="false" size="12"/><Font background="[0,0,0]" family="Serif" foreground="[0,128,128]" hyperlink="true" name="Hyperlink" opaque="false" size="12" underline="true"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" foreground="[0,0,0]" italic="false" name="Text" opaque="false" size="12" underline="false"/><Font background="[0,0,0]" family="Monospaced" foreground="[0,0,255]" name="Warning" opaque="false" readonly="true" size="12"/><Font background="[0,0,0]" family="Monospaced" foreground="[0,0,255]" name="Line Printed Output" opaque="false" readonly="true" size="12"/><Font background="[0,0,0]" family="Monospaced" foreground="[255,0,255]" name="Error" opaque="false" readonly="true" size="12"/><Font background="[0,0,0]" family="Lucida Bright" foreground="[0,0,255]" name="2D Output" opaque="false" readonly="true" size="12"/></Styles><Group><Input><Text-field layout="Normal" style="Text"><Font bold="true">This worksheet contains data and computations related to the article "On distinguishing trees by their chromatic symmetric functions", by Jeremy L. Martin, Matthew Morin, and Jennifer D. Wagner (</Font><Hyperlink bold="true" executable="false" italic="false" linktarget="http://arxiv.org/abs/math.CO/0609339" style="Hyperlink">arXiv:math.CO/0609339</Hyperlink><Font bold="true">), henceforth [MMW].  It was last modified by Jeremy L. Martin on 5/16/07 and may be freely used and shared for any noncommercial research purpose.</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Load Maple's <Font italic="true">combinat</Font>  package and John Stembridge's <Font italic="true">SF</Font>  package, freely available at <Hyperlink bold="false" executable="false" italic="false" linktarget="http://www.math.lsa.umich.edu/~jrs/maple.html#SF" style="Hyperlink">http://www.math.lsa.umich.edu/~jrs/maple.html#SF</Hyperlink></Text-field></Input><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">with(combinat):
read("/home/jmartin/maple/SF2.4v.txt"): ## you will presumably need to change the location of the file!
withSF():</Text-field></Input><Input><Text-field layout="Normal" style="Text">Convert a list of integers to a power-sum symmetric function</Text-field></Input><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">P := lambda -&gt; mul(cat(p,kk),kk=lambda):</Text-field></Input><Input><Text-field layout="Normal" style="Text">Define the monomial symmetric functions</Text-field></Input><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">dual_basis(m,h):</Text-field></Input><Output><Text-field layout="Warning" style="Warning">Warning, the protected name Chi has been redefined and unprotected</Text-field></Output><Output><Text-field layout="Normal" style="Line Printed Output">SF 2.4v loaded. Run 'withSF()' to use abbreviated names.
Warning: new definition for  conjugate</Text-field></Output></Group><Group><Input><Text-field layout="Normal" style="Text">The number <Font family="SymbolPi">y (l</Font>, i, j<Font family="SymbolPi">)</Font> defined in [MMW]</Text-field></Input><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">psi := proc(lambda,a,b)
  option remember:
  local n,kk,ell:
  ell := nops(lambda):
  n := add(kk,kk=lambda):
  binomial(ell-1,ell-n+a+b) * 
  add( binomial(lambda[kk]-1,a),kk=1..ell ):
end:</Text-field></Input><Input><Text-field layout="Normal" style="Text">The symmetric function <Font family="SymbolPi">Q = Q</Font>(<Font italic="true">n</Font>) whose scalar product with X(T) is the connector polynomial of T.</Text-field><Text-field layout="Normal" style="Text">(This is called <Font family="SymbolPi">Y</Font> instead of <Font family="SymbolPi">Q</Font> in [MMW], but Maple reserves the symbol <Font family="SymbolPi">Y</Font> for something else.)</Text-field></Input><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Theta := proc(n)
  option remember:
  expand(add(add( (-1)^(a+b)*'x'^a*'y'^b *
    add(psi(lambda,a,b) * P(lambda)/zee(lambda), lambda=Par(n)),
  b=0..n-1),a=1..n-1))
end:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Conjecture 6 of [MMW] (the "positivity conjecture") states that<Font bold="true"> <Font foreground="[0,0,255]">(-1)<Font subscript="false" superscript="true">(number of even parts of <Font family="SymbolPi">l</Font>)</Font> <Font family="SymbolPi">y (l</Font>, i, j<Font family="SymbolPi">)</Font> &gt;= 0</Font> for all <Font family="SymbolPi">l</Font>, i, j.</Font>
Conjecture 7 of [MMW] (the "integrality conjecture") states that <Font bold="true" foreground="[0,0,255]" italic="true">z</Font><Font bold="true" family="SymbolPi" foreground="[0,0,255]" subscript="true" superscript="false">l  </Font><Font bold="true" family="SymbolPi" foreground="[0,0,255]">y (l</Font><Font bold="true" foreground="[0,0,255]">, i, j<Font family="SymbolPi">)</Font></Font><Font bold="true">  is an integer for all <Font family="SymbolPi">l</Font>, i, j.</Font></Text-field><Text-field layout="Normal" style="Text">      The following loop verifies these conjectures for small <Font italic="true">n </Font>;  I have run it for <Font italic="true">n</Font> &lt;= 17.  The outer loop runs over <Font italic="true">n</Font>  (the number of vertices), and the inner loop over all partitions <Font family="SymbolPi">l</Font> of <Font italic="true">n</Font>.  The algorithm extracts the coefficient of <Font family="SymbolPi">l</Font> in <Font family="SymbolPi">Q</Font>(<Font italic="true">n</Font>) by taking the scalar product with <Font italic="true">m</Font><Font family="SymbolPi" subscript="true" superscript="false">l  </Font>(the dual basis to the <Font italic="true">h</Font><Font family="SymbolPi" subscript="true" superscript="false">l </Font>).  The first counterexample to each conjecture is printed out, and all counterexamples are recorded in the lists NonPositiveLambdas, NonIntegralLambdas.  The time to check each <Font italic="true">n</Font> seems to be O(2<Font italic="true" subscript="false" superscript="true">n</Font> ).  On my computer (a Dell Precision 370 running Maple under Linux), it took about 17 minutes (just over 1000 seconds) to check the case <Font italic="true">n </Font>= 17.</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">NonPositiveLambdas := []:
NonIntegralLambdas := []:
n := 2:
while true do
## while n &lt;= 17 do
  ## you can change the value of 17 if desired
   tm := time():
   T := toh(Theta(n)):
   for lambda in Par(n) do
      xi := scalar(Theta(n), m[op(lambda)]):
      EvenParts := 0: for i in lambda do if type(i,even) then EvenParts := EvenParts + 1 fi od:
      if not type((-1)^EvenParts*xi, polynom(positive)) then
         NonPositiveLambdas := [op(NonPositiveLambdas), lambda]:
         if NonPositiveLambdas=[] then print("Positivity Conjecture fails for ",lambda) fi
      fi:
      if not type(zee(lambda)*xi, polynom(integer)) then
         NonIntegralLambdas := [op(NonIntegralLambdas), lambda]:
         if NonIntegralLambdas=[] then print("Integrality Conjecture fails for ",lambda) fi
      fi:
   od:
   print(n,time()-tm,' seconds'):  ## keep track of time
   n := n+1:
od:
NonPositiveLambdas;
NonIntegralLambdas;</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIiMkIiM2ISIkSShzZWNvbmRzRzYi</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIiQkIiNEISIkSShzZWNvbmRzRzYi</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIiUkIiNSISIkSShzZWNvbmRzRzYi</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIiYkIiNsISIkSShzZWNvbmRzRzYi</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIickIiRnIiEiJEkoc2Vjb25kc0c2Ig==</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIigkIiQ1JSEiJEkoc2Vjb25kc0c2Ig==</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIikkIiRnJyEiJEkoc2Vjb25kc0c2Ig==</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIiokIiVTOCEiJEkoc2Vjb25kc0c2Ig==</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIzUkIiU7RyEiJEkoc2Vjb25kc0c2Ig==</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIzYkIiVYYSEiJEkoc2Vjb25kc0c2Ig==</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIzckIiYwRCIhIiRJKHNlY29uZHNHNiI=</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIzgkIiZeXyMhIiRJKHNlY29uZHNHNiI=</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIzkkIiZiaiYhIiRJKHNlY29uZHNHNiI=</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIzokIicwbzchIiRJKHNlY29uZHNHNiI=</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIzskIic+PEchIiRJKHNlY29uZHNHNiI=</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIzwkIicpKlFrISIkSShzZWNvbmRzRzYi</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIz0kIihRXWsiISIkSShzZWNvbmRzRzYi</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIz4kIihjL3kkISIkSShzZWNvbmRzRzYi</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiUiIz8kIikhMzkvIiEiJEkoc2Vjb25kc0c2Ig==</Equation></Text-field></Output><Output><Text-field layout="Error" style="Error">Error, (in collect/series) Maple was unable to allocate enough memory to complete this computation.  Please see ?alloc</Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM3Ig==</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM3Ig==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Text-field/><Text-field/></Worksheet>